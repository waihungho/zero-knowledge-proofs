```go
// Package zkgolang provides a set of Zero-Knowledge Proof (ZKP) functions
// implemented in Golang using elliptic curve cryptography.
//
// This package is designed for educational purposes and exploring various
// ZKP concepts building on Pedersen commitments and Sigma-protocol-like
// structures. It is NOT intended for production use without extensive security
// review and auditing.
//
// Outline:
// 1. Global Curve Parameters and Generators
// 2. Scalar and Point Helper Functions
// 3. Data Structures (Commitments, Proofs)
// 4. Base Commitment Generation
// 5. Core Knowledge Proof (Prove/Verify knowledge of value and blinding factor)
// 6. Equality Proofs (Value, Blinding Factor)
// 7. Relationship Proofs (Sum, Difference, Linear Combination, Adjacency, Sum to Zero)
// 8. Property Proofs (Even, Odd, Multiple of Public, Equals Public Constant)
// 9. Composed Proofs (Committed value is Private Key, Value is One of Public List)
// 10. Simplified Proofs (Knowledge of Value Only, Knowledge of Blinding Only)
// 11. Vector/Aggregate Proofs (Sum of Vector Elements)
// 12. Example Usage (Not required by prompt, but good for testing)
//
// Function Summary (Total: 29 functions including generation/verification pairs and helpers):
//
// - setupCurveAndGenerators(): Initializes elliptic curve and generators.
// - GeneratePedersenCommitment(value, blinding *big.Int): Creates a Pedersen commitment C = G^value * H^blinding.
//
// - ProveKnowledgeOfSecrets(C *elliptic.Point, value, blinding *big.Int) (*SecretsProof, error):
//   Proves knowledge of 'value' and 'blinding' for commitment C = G^value * H^blinding.
// - VerifyKnowledgeOfSecrets(C *elliptic.Point, proof *SecretsProof) bool:
//   Verifies the proof generated by ProveKnowledgeOfSecrets.
//
// - ProveEqualityOfCommittedValues(C1, C2 *elliptic.Point, value *big.Int, r1, r2 *big.Int) (*EqualityProof, error):
//   Proves that the secret committed in C1 (with r1) and C2 (with r2) is the same value.
// - VerifyEqualityOfCommittedValues(C1, C2 *elliptic.Point, proof *EqualityProof) bool:
//   Verifies the proof generated by ProveEqualityOfCommittedValues.
//
// - ProveSumEqualsPublicConstant(C1, C2 *elliptic.Point, v1, r1, v2, r2, publicSum *big.Int) (*PublicConstantSumProof, error):
//   Proves v1 + v2 = publicSum, where v1, v2 are secrets committed in C1, C2 respectively.
// - VerifySumEqualsPublicConstant(C1, C2 *elliptic.Point, publicSum *big.Int, proof *PublicConstantSumProof) bool:
//   Verifies the proof generated by ProveSumEqualsPublicConstant.
//
// - ProveDifferenceEqualsPublicConstant(C1, C2 *elliptic.Point, v1, r1, v2, r2, publicDiff *big.Int) (*PublicConstantDifferenceProof, error):
//   Proves v1 - v2 = publicDiff, where v1, v2 are secrets committed in C1, C2.
// - VerifyDifferenceEqualsPublicConstant(C1, C2 *elliptic.Point, publicDiff *big.Int, proof *PublicConstantDifferenceProof) bool:
//   Verifies the proof generated by ProveDifferenceEqualsPublicConstant.
//
// - ProveLinearCombinationEqualsPublicConstant(Cs []*elliptic.Point, vs, rs []*big.Int, coeffs []*big.Int, publicConstant *big.Int) (*LinearCombinationProof, error):
//   Proves sum(coeffs[i] * vs[i]) = publicConstant for secrets vs[i] in Cs[i].
// - VerifyLinearCombinationEqualsPublicConstant(Cs []*elliptic.Point, coeffs []*big.Int, publicConstant *big.Int, proof *LinearCombinationProof) bool:
//   Verifies the proof generated by ProveLinearCombinationEqualsPublicConstant.
//
// - ProveValueIsEven(C *elliptic.Point, value, blinding *big.Int) (*EvenOddProof, error):
//   Proves the secret 'value' in C is an even number.
// - VerifyValueIsEven(C *elliptic.Point, proof *EvenOddProof) bool:
//   Verifies the proof generated by ProveValueIsEven.
//
// - ProveValueIsOdd(C *elliptic.Point, value, blinding *big.Int) (*EvenOddProof, error):
//   Proves the secret 'value' in C is an odd number.
// - VerifyValueIsOdd(C *elliptic.Point, proof *EvenOddProof) bool:
//   Verifies the proof generated by ProveValueIsOdd.
//
// - ProveValueIsMultipleOfPublic(C *elliptic.Point, value, blinding, publicFactor *big.Int) (*MultipleProof, error):
//   Proves the secret 'value' in C is a multiple of 'publicFactor'.
// - VerifyValueIsMultipleOfPublic(C *elliptic.Point, publicFactor *big.Int, proof *MultipleProof) bool:
//   Verifies the proof generated by ProveValueIsMultipleOfPublic.
//
// - ProveValueEqualsPublicConstant(C *elliptic.Point, value, blinding, publicValue *big.Int) (*PublicConstantEqualityProof, error):
//   Proves the secret 'value' in C is equal to 'publicValue'.
// - VerifyValueEqualsPublicConstant(C *elliptic.Point, publicValue *big.Int, proof *PublicConstantEqualityProof) bool:
//   Verifies the proof generated by ProveValueEqualsPublicConstant.
//
// - ProveKnowledgeOfPrivateKey(C *elliptic.Point, value, blinding *big.Int, publicKey *elliptic.Point) (*PrivateKeyProof, error):
//   Proves knowledge of 'value' and 'blinding' for C=G^value H^blinding AND that G^value = publicKey.
// - VerifyKnowledgeOfPrivateKey(C *elliptic.Point, publicKey *elliptic.Point, proof *PrivateKeyProof) bool:
//   Verifies the proof generated by ProveKnowledgeOfPrivateKey.
//
// - ProveValueIsOneOfPublicList(C *elliptic.Point, value, blinding *big.Int, publicList []*big.Int) (*OrProof, error):
//   Proves the secret 'value' in C is equal to one of the values in 'publicList' (using OR proof). Limited to 2 values for simplicity in this implementation.
// - VerifyValueIsOneOfPublicList(C *elliptic.Point, publicList []*big.Int, proof *OrProof) bool:
//   Verifies the proof generated by ProveValueIsOneOfPublicList.
//
// - ProveKnowledgeOfSecretForCommitmentOnly(C *elliptic.Point, value *big.Int) (*ValueOnlyProof, error):
//   Proves knowledge of 'value' for C = G^value (no blinding factor).
// - VerifyKnowledgeOfSecretForCommitmentOnly(C *elliptic.Point, proof *ValueOnlyProof) bool:
//   Verifies the proof generated by ProveKnowledgeOfSecretForCommitmentOnly.
//
// - ProveKnowledgeOfBlindingFactorOnly(C *elliptic.Point, blinding *big.Int) (*BlindingOnlyProof, error):
//   Proves knowledge of 'blinding' for C = H^blinding (no value).
// - VerifyKnowledgeOfBlindingFactorOnly(C *elliptic.Point, proof *BlindingOnlyProof) bool:
//   Verifies the proof generated by ProveKnowledgeOfBlindingFactorOnly.
//
// - ProveSecretsSumToZero(C1, C2 *elliptic.Point, v1, r1, v2, r2 *big.Int) (*SumZeroProof, error):
//   Proves v1 + v2 = 0, where v1, v2 are secrets committed in C1, C2.
// - VerifySecretsSumToZero(C1, C2 *elliptic.Point, proof *SumZeroProof) bool:
//   Verifies the proof generated by ProveSecretsSumToZero.
//
// - ProveKnowledgeOfSecretsForVectorSum(Cs []*elliptic.Point, vs, rs []*big.Int, publicSum *big.Int) (*VectorSumProof, error):
//   Proves sum(vs[i]) = publicSum for secrets vs[i] in Cs[i].
// - VerifyKnowledgeOfSecretsForVectorSum(Cs []*elliptic.Point, publicSum *big.Int, proof *VectorSumProof) bool:
//   Verifies the proof generated by ProveKnowledgeOfSecretsForVectorSum.
//
// - ProveSecretsAreAdjacent(C1, C2 *elliptic.Point, v1, r1, v2, r2 *big.Int) (*AdjacentProof, error):
//   Proves v2 = v1 + 1, where v1, v2 are secrets committed in C1, C2.
// - VerifySecretsAreAdjacent(C1, C2 *elliptic.Point, proof *AdjacentProof) bool:
//   Verifies the proof generated by ProveSecretsAreAdjacent.
package zkgolang

import (
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"
	"errors"
	"fmt"
	"io"
	"math/big"
)

// 1. Global Curve Parameters and Generators

var (
	curve elliptic.Curve
	G, H  *elliptic.Point // G is the standard generator, H is another generator
	N     *big.Int        // The order of the group
)

func init() {
	setupCurveAndGenerators()
}

// setupCurveAndGenerators initializes the curve and generates G and H.
// G is the standard base point. H is derived from G using a hash-to-point
// like mechanism for independence.
func setupCurveAndGenerators() {
	curve = elliptic.P256() // Using NIST P-256 curve
	N = curve.Params().N     // The order of the group (number of points)

	// G is the standard generator for P256
	G = curve.Params().Gx
	Gy := curve.Params().Gy
	G = elliptic.NewCurvePoint(curve, G, Gy)

	// H is another generator. We derive it deterministically but in a way
	// that it's highly unlikely to be a small scalar multiple of G.
	// H = hash_to_point("another generator") or similar.
	// Simple approach: H = hash_result * G
	hHasher := sha256.New()
	hHasher.Write([]byte("zkgolang-another-generator"))
	hHash := hHasher.Sum(nil)
	hScalar := new(big.Int).SetBytes(hHash)
	hScalar.Mod(hScalar, N) // Ensure scalar is within group order

	hx, hy := curve.ScalarBaseMult(hScalar.Bytes()) // G * hScalar
	H = elliptic.NewCurvePoint(curve, hx, hy)

	// Double check H is not G (it shouldn't be unless hash_result was 1)
	if H.X.Cmp(G.X) == 0 && H.Y.Cmp(G.Y) == 0 {
		panic("Initialization error: H collided with G.")
	}
}

// 2. Scalar and Point Helper Functions

// randScalar generates a random scalar in [1, N-1].
func randScalar(rand io.Reader) (*big.Int, error) {
	s, err := rand.Int(rand, N)
	if err != nil {
		return nil, err
	}
	// Ensure not zero, technically N-1 is max, 1 is min for non-zero
	if s.Sign() == 0 {
		return randScalar(rand) // Retry if zero
	}
	return s, nil
}

// hashToScalar hashes inputs and returns a scalar modulo N.
func hashToScalar(domainSeparator string, inputs ...[]byte) (*big.Int) {
	hasher := sha256.New()
	hasher.Write([]byte(domainSeparator))
	for _, input := range inputs {
		hasher.Write(input)
	}
	hashBytes := hasher.Sum(nil)
	// Convert hash to scalar by interpreting as big-endian and reducing modulo N.
	// Ensure scalar is in [0, N-1]. Using bits is slightly safer than SetBytes
	// for potential reductions for curves where N has specific high bits set,
	// but SetBytes followed by Mod is generally sufficient for standard curves.
	scalar := new(big.Int).SetBytes(hashBytes)
	scalar.Mod(scalar, N)

	return scalar
}

// scalarAdd adds two scalars modulo N.
func scalarAdd(a, b *big.Int) *big.Int {
	return new(big.Int).Add(a, b).Mod(new(big.Int).Add(a, b), N)
}

// scalarSub subtracts two scalars modulo N.
func scalarSub(a, b *big.Int) *big.Int {
	// (a - b) mod N is (a + (-b mod N)) mod N
	bNeg := new(big.Int).Neg(b).Mod(new(big.Int).Neg(b), N)
	return scalarAdd(a, bNeg)
}

// scalarMul multiplies two scalars modulo N.
func scalarMul(a, b *big.Int) *big.Int {
	return new(big.Int).Mul(a, b).Mod(new(big.Int).Mul(a, b), N)
}

// scalarInverse computes the modular multiplicative inverse modulo N.
func scalarInverse(a *big.Int) (*big.Int, error) {
	if a.Sign() == 0 {
		return nil, errors.New("cannot compute inverse of zero")
	}
	return new(big.Int).ModInverse(a, N), nil
}

// pointAdd adds two elliptic curve points. Handles the point at infinity.
func pointAdd(p1, p2 *elliptic.Point) *elliptic.Point {
	if p1.X == nil && p1.Y == nil { // Point at infinity
		return p2
	}
	if p2.X == nil && p2.Y == nil { // Point at infinity
		return p1
	}
	x, y := curve.Add(p1.X, p1.Y, p2.X, p2.Y)
	return elliptic.NewCurvePoint(curve, x, y)
}

// pointSub subtracts point p2 from p1 (p1 + (-p2)).
func pointSub(p1, p2 *elliptic.Point) *elliptic.Point {
	if p2.X == nil && p2.Y == nil { // Subtracting infinity
		return p1
	}
	// Negate p2 (x, y) -> (x, -y mod P)
	p2NegX := new(big.Int).Set(p2.X)
	p2NegY := new(big.Int).Neg(p2.Y).Mod(new(big.Int).Neg(p2.Y), curve.Params().P)
	p2Neg := elliptic.NewCurvePoint(curve, p2NegX, p2NegY)
	return pointAdd(p1, p2Neg)
}


// pointScalarMult performs scalar multiplication on a point.
func pointScalarMult(p *elliptic.Point, scalar *big.Int) *elliptic.Point {
	if p.X == nil && p.Y == nil || scalar.Sign() == 0 { // Point at infinity or scalar is zero
		return elliptic.NewCurvePoint(curve, nil, nil) // Return point at infinity
	}
	// Ensure scalar is positive by taking modulo N
	scalar = new(big.Int).Mod(scalar, N)
	if scalar.Sign() == 0 { // If modulo resulted in zero
         return elliptic.NewCurvePoint(curve, nil, nil)
    }

	x, y := curve.ScalarMult(p.X, p.Y, scalar.Bytes())
	return elliptic.NewCurvePoint(curve, x, y)
}

// pointMultiScalarMult computes P1*s1 + P2*s2 + ...
func pointMultiScalarMult(points []*elliptic.Point, scalars []*big.Int) (*elliptic.Point, error) {
	if len(points) != len(scalars) {
		return nil, errors.New("mismatched number of points and scalars")
	}
	if len(points) == 0 {
		return elliptic.NewCurvePoint(curve, nil, nil), nil // Point at infinity
	}

	// P256 has an optimized MultiScalarMult function
	pointsBytes := make([][]byte, len(points))
	scalarsBytes := make([][]byte, len(scalars))
	for i := range points {
		// Pad scalar bytes to curve.Params().BitSize / 8 for ScalarBaseMult or ScalarMult
		// Ensure scalar is non-negative by taking modulo N
		scalar := new(big.Int).Mod(scalars[i], N)
		scalarBytes := scalar.Bytes()
		paddedScalarBytes := make([]byte, (curve.Params().BitSize+7)/8)
		copy(paddedScalarBytes[len(paddedScalarBytes)-len(scalarBytes):], scalarBytes)

		// Serialize point for ScalarMult
		pointBytes := elliptic.Marshal(curve, points[i].X, points[i].Y)

		pointsBytes[i] = pointBytes
		scalarsBytes[i] = paddedScalarBytes
	}

	// Note: crypto/elliptic does *not* expose a public multi-scalar multiplication
	// that takes arbitrary points, only ScalarBaseMult (G*s) and ScalarMult (P*s).
	// Implementing a generic multi-scalar mult requires manual additions or
	// using internal curve methods if available (they aren't exposed).
	// Let's do it manually for now, which is less efficient but works.
	// Result = s1*P1 + s2*P2 + ...
	result := elliptic.NewCurvePoint(curve, nil, nil) // Start with point at infinity
	for i := range points {
		term := pointScalarMult(points[i], scalars[i])
		result = pointAdd(result, term)
	}

	return result, nil
}


// 3. Data Structures

// Commitment represents a Pedersen commitment C = G^value * H^blinding
type Commitment struct {
	C *elliptic.Point // The commitment point
}

// Proof structs hold the prover's response (A, z) or variations.

// SecretsProof proves knowledge of value and blinding factor for C=G^v H^r
type SecretsProof struct {
	A   *elliptic.Point // Prover's commitment A = G^v * H^s
	Zx  *big.Int        // Response z_x = v + e * value
	Zr  *big.Int        // Response z_r = s + e * blinding
}

// ValueOnlyProof proves knowledge of value for C=G^v
type ValueOnlyProof struct {
	A   *elliptic.Point // Prover's commitment A = G^v_rand
	Zx  *big.Int        // Response z_x = v_rand + e * value
}

// BlindingOnlyProof proves knowledge of blinding factor for C=H^r
type BlindingOnlyProof struct {
	A   *elliptic.Point // Prover's commitment A = H^s
	Zr  *big.Int        // Response z_r = s + e * blinding
}

// EqualityProof proves committed values in C1 and C2 are equal
type EqualityProof struct {
	A1  *elliptic.Point // Prover's commitment 1 A1 = G^v * H^s1
	A2  *elliptic.Point // Prover's commitment 2 A2 = G^v * H^s2 (same v)
	Zv  *big.Int        // Response z_v = v + e * value
	Zs1 *big.Int        // Response z_s1 = s1 + e * r1
	Zs2 *big.Int        // Response z_s2 = s2 + e * r2
}

// PublicConstantSumProof proves v1 + v2 = K for C1, C2
// This proof proves knowledge of r1+r2 for C1*C2 * G^-K using base H
type PublicConstantSumProof struct {
	A  *elliptic.Point // Prover's commitment A = H^s_sum
	Zr *big.Int        // Response z_r = s_sum + e * (r1 + r2)
}

// PublicConstantDifferenceProof proves v1 - v2 = K for C1, C2
// This proof proves knowledge of r1-r2 for C1/C2 * G^-K using base H
type PublicConstantDifferenceProof struct {
	A  *elliptic.Point // Prover's commitment A = H^s_diff
	Zr *big.Int        // Response z_r = s_diff + e * (r1 - r2)
}

// LinearCombinationProof proves sum(coeffs[i] * vs[i]) = K
// Proves knowledge of sum(coeffs[i] * rs[i]) for prod(C_i^coeffs[i]) * G^-K using base H
type LinearCombinationProof struct {
	A  *elliptic.Point // Prover's commitment A = H^s_sum_coeffs_r
	Zr *big.Int        // Response z_r = s_sum_coeffs_r + e * sum(coeffs[i] * rs[i])
}

// EvenOddProof proves committed value is even or odd
// For even: Prove knowledge of k, r for C w.r.t G^2 and H
// For odd: Prove knowledge of k, r for C*G^-1 w.r.t G^2 and H
type EvenOddProof struct {
	A  *elliptic.Point // Prover's commitment A = (G^2)^v * H^s
	Zk *big.Int        // Response z_k = v + e * k (where value = 2k or 2k+1)
	Zr *big.Int        // Response z_r = s + e * r
}

// MultipleProof proves committed value is a multiple of publicFactor
// Prove knowledge of k, r for C w.r.t G^publicFactor and H
type MultipleProof struct {
	A  *elliptic.Point // Prover's commitment A = (G^publicFactor)^v * H^s
	Zk *big.Int        // Response z_k = v + e * k (where value = k * publicFactor)
	Zr *big.Int        // Response z_r = s + e * r
}

// PublicConstantEqualityProof proves committed value equals a public constant K
// Prove knowledge of r for C * G^-K using base H
type PublicConstantEqualityProof struct {
	A  *elliptic.Point // Prover's commitment A = H^s
	Zr *big.Int        // Response z_r = s + e * r
}

// PrivateKeyProof proves committed value is SK for PK and committed in C
// Combines KnowledgeOfSecrets proof with EqualityProof between committed value and SK of PK
type PrivateKeyProof struct {
	SecretsA *elliptic.Point // A from SecretsProof (G^v1 H^s1)
	SecretsZx *big.Int       // Zx from SecretsProof (v1 + e*value)
	SecretsZr *big.Int       // Zr from SecretsProof (s1 + e*blinding)
	// Equality proof part: Prove value == value' where G^value' = publicKey
	// Prover knows value and PK. Prove knowledge of value for G^value and C
	// Simplified: Prove knowledge of value for C AND G^value = PK
	// This can be done with two linked proofs or a combined proof.
	// Let's make it a combined knowledge proof for (value, blinding) for C and (value) for PK.
	// A = G^v H^s for C
	// A_pk = G^v for PK
	// Zv = v + e*value (shared v)
	// Zs = s + e*blinding
	EqPkA *elliptic.Point // Commitment A_pk = G^v_pk (using a fresh random v_pk) -- NO, must use the SAME secret 'value'
	// Let's refine: Prove knowledge of value, r for C AND knowledge of value for G^value = PK.
	// Prove knowledge of value, r for C using (A_c = G^vc H^sc, z_vc, z_sc)
	// Prove knowledge of value for PK=G^value using (A_pk = G^vpk, z_vpk)
	// Combined challenge derived from C, PK, A_c, A_pk.
	// Requires proving z_vc = v_c + e*value and z_vpk = v_pk + e*value, so (z_vc - v_c) = (z_vpk - v_pk)
	// This can be done with a combined proof.
	// Prover picks v, s. Computes A_c = G^v H^s, A_pk = G^v.
	// Challenge e from C, PK, A_c, A_pk.
	// Response z_v = v + e*value, z_s = s + e*blinding.
	// Proof: (A_c, A_pk, z_v, z_s).
	CommitmentA *elliptic.Point // Prover's commitment A_c = G^v * H^s
	PublicKeyA  *elliptic.Point // Prover's commitment A_pk = G^v
	Zv          *big.Int        // Response z_v = v + e * value
	Zs          *big.Int        // Response z_s = s + e * blinding
}

// OrProof proves committed value is one of a public list.
// This implementation is simplified for a list of size 2: value == V1 OR value == V2
// Uses Chaum-Pedersen OR proof structure.
type OrProof struct {
	// Sub-proof 1 (for value == V1)
	A1  *elliptic.Point // Commitment A1 = H^s1 (Target1 = C*G^-V1, prove knowledge of r for Target1 w.r.t H)
	Z1  *big.Int        // Response z1 = s1 + e1 * r
	E1  *big.Int        // Challenge e1 (random for simulation)
	// Sub-proof 2 (for value == V2)
	A2  *elliptic.Point // Commitment A2 = H^s2 (Target2 = C*G^-V2, prove knowledge of r for Target2 w.r.t H)
	Z2  *big.Int        // Response z2 = s2 + e2 * r
	E2  *big.Int        // Challenge e2 (derived e - e1 for the real proof)
}

// VectorSumProof proves sum(vs[i]) = K
// Special case of LinearCombinationProof with all coeffs = 1.
// Proves knowledge of sum(rs[i]) for prod(C_i) * G^-K using base H
type VectorSumProof struct {
	A  *elliptic.Point // Prover's commitment A = H^s_sum_r
	Zr *big.Int        // Response z_r = s_sum_r + e * sum(rs[i])
}

// AdjacentProof proves v2 = v1 + 1
// Special case of DifferenceEqualsPublicConstant with PublicDiff = 1.
// Proves knowledge of r1-r2 for C1/C2 * G^-1 using base H
type AdjacentProof struct {
	A  *elliptic.Point // Prover's commitment A = H^s_diff
	Zr *big.Int        // Response z_r = s_diff + e * (r1 - r2)
}


// 4. Base Commitment Generation

// GeneratePedersenCommitment creates a Pedersen commitment C = G^value * H^blinding
// Prover needs to know 'value' and 'blinding' to open or prove things about C.
func GeneratePedersenCommitment(value, blinding *big.Int) (*Commitment, error) {
	if value == nil || blinding == nil {
		return nil, errors.New("value and blinding cannot be nil")
	}

	// Ensure value and blinding are within scalar field N
	value = new(big.Int).Mod(value, N)
	blinding = new(big.Int).Mod(blinding, N)

	// C = G^value * H^blinding
	termG := pointScalarMult(G, value)
	termH := pointScalarMult(H, blinding)
	C := pointAdd(termG, termH)

	return &Commitment{C: C}, nil
}

// 5. Core Knowledge Proof (Prove/Verify knowledge of value and blinding factor)

// ProveKnowledgeOfSecrets proves knowledge of 'value' and 'blinding' for C=G^value H^blinding.
func ProveKnowledgeOfSecrets(C *elliptic.Point, value, blinding *big.Int) (*SecretsProof, error) {
	if C == nil || C.X == nil || C.Y == nil || value == nil || blinding == nil {
		return nil, errors.New("invalid inputs")
	}

	// 1. Prover picks random scalars v, s
	v, err := randScalar(rand.Reader)
	if err != nil {
		return nil, fmt.Errorf("failed to generate random v: %w", err)
	}
	s, err := randScalar(rand.Reader)
	if err != nil {
		return nil, fmt.Errorf("failed to generate random s: %w", err)
	}

	// 2. Prover computes commitment A = G^v * H^s
	termG := pointScalarMult(G, v)
	termH := pointScalarMult(H, s)
	A := pointAdd(termG, termH)

	// 3. Prover/Verifier generate challenge e = Hash(C, A, G, H, N)
	// Use a domain separator to prevent collision with other proof types
	e := hashToScalar("zkp-secrets-proof", elliptic.Marshal(curve, C.X, C.Y), elliptic.Marshal(curve, A.X, A.Y), elliptic.Marshal(curve, G.X, G.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// 4. Prover computes responses z_x = v + e*value mod N, z_r = s + e*blinding mod N
	z_x := scalarAdd(v, scalarMul(e, value))
	z_r := scalarAdd(s, scalarMul(e, blinding))

	// 5. Proof is (A, z_x, z_r)
	return &SecretsProof{A: A, Zx: z_x, Zr: z_r}, nil
}

// VerifyKnowledgeOfSecrets verifies the proof generated by ProveKnowledgeOfSecrets.
// Checks if G^z_x * H^z_r == A * C^e
func VerifyKnowledgeOfSecrets(C *elliptic.Point, proof *SecretsProof) bool {
	if C == nil || C.X == nil || C.Y == nil || proof == nil || proof.A == nil || proof.A.X == nil || proof.A.Y == nil || proof.Zx == nil || proof.Zr == nil {
		return false // Invalid inputs
	}

	// 1. Verifier regenerates challenge e
	e := hashToScalar("zkp-secrets-proof", elliptic.Marshal(curve, C.X, C.Y), elliptic.Marshal(curve, proof.A.X, proof.A.Y), elliptic.Marshal(curve, G.X, G.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// 2. Verifier computes the left side of the equation: G^z_x * H^z_r
	leftG := pointScalarMult(G, proof.Zx)
	leftH := pointScalarMult(H, proof.Zr)
	leftSide := pointAdd(leftG, leftH)

	// 3. Verifier computes the right side of the equation: A * C^e
	C_e := pointScalarMult(C, e)
	rightSide := pointAdd(proof.A, C_e)

	// 4. Verifier checks if leftSide == rightSide
	return leftSide.X.Cmp(rightSide.X) == 0 && leftSide.Y.Cmp(rightSide.Y) == 0
}

// 6. Equality Proofs (Value, Blinding Factor)

// ProveEqualityOfCommittedValues proves that the secret committed in C1 and C2 is the same value.
// C1 = G^value * H^r1, C2 = G^value * H^r2. Proves knowledge of value, r1, r2 s.t. this holds.
// Prover picks random v, s1, s2. Computes A1 = G^v H^s1, A2 = G^v H^s2.
// Challenge e from C1, C2, A1, A2...
// Response z_v = v + e*value, z_s1 = s1 + e*r1, z_s2 = s2 + e*r2.
// Verifier checks G^z_v H^z_s1 == A1 * C1^e AND G^z_v H^z_s2 == A2 * C2^e.
func ProveEqualityOfCommittedValues(C1, C2 *elliptic.Point, value *big.Int, r1, r2 *big.Int) (*EqualityProof, error) {
	if C1 == nil || C1.X == nil || C2 == nil || C2.X == nil || value == nil || r1 == nil || r2 == nil {
		return nil, errors.New("invalid inputs")
	}

	// 1. Prover picks random scalars v, s1, s2
	v, err := randScalar(rand.Reader)
	if err != nil {
		return nil, fmt.Errorf("failed to generate random v: %w", err)
	}
	s1, err := randScalar(rand.Reader)
	if err != nil {
		return nil, fmt.Errorf("failed to generate random s1: %w", err)
	}
	s2, err := randScalar(rand.Reader)
	if err != nil {
		return nil, fmt.Errorf("failed to generate random s2: %w", err)
	}

	// 2. Prover computes commitments A1 = G^v * H^s1, A2 = G^v * H^s2
	termG_v := pointScalarMult(G, v)
	A1 := pointAdd(termG_v, pointScalarMult(H, s1))
	A2 := pointAdd(termG_v, pointScalarMult(H, s2)) // Uses the same v

	// 3. Prover/Verifier generate challenge e
	e := hashToScalar("zkp-equality-proof", elliptic.Marshal(curve, C1.X, C1.Y), elliptic.Marshal(curve, C2.X, C2.Y), elliptic.Marshal(curve, A1.X, A1.Y), elliptic.Marshal(curve, A2.X, A2.Y), elliptic.Marshal(curve, G.X, G.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// 4. Prover computes responses
	z_v := scalarAdd(v, scalarMul(e, value))
	z_s1 := scalarAdd(s1, scalarMul(e, r1))
	z_s2 := scalarAdd(s2, scalarMul(e, r2))

	// 5. Proof is (A1, A2, z_v, z_s1, z_s2)
	return &EqualityProof{A1: A1, A2: A2, Zv: z_v, Zs1: z_s1, Zs2: z_s2}, nil
}

// VerifyEqualityOfCommittedValues verifies the proof generated by ProveEqualityOfCommittedValues.
// Checks G^z_v H^z_s1 == A1 * C1^e AND G^z_v H^z_s2 == A2 * C2^e.
func VerifyEqualityOfCommittedValues(C1, C2 *elliptic.Point, proof *EqualityProof) bool {
	if C1 == nil || C1.X == nil || C2 == nil || C2.X == nil || proof == nil || proof.A1 == nil || proof.A1.X == nil || proof.A2 == nil || proof.A2.X == nil || proof.Zv == nil || proof.Zs1 == nil || proof.Zs2 == nil {
		return false // Invalid inputs
	}

	// 1. Verifier regenerates challenge e
	e := hashToScalar("zkp-equality-proof", elliptic.Marshal(curve, C1.X, C1.Y), elliptic.Marshal(curve, C2.X, C2.Y), elliptic.Marshal(curve, proof.A1.X, proof.A1.Y), elliptic.Marshal(curve, proof.A2.X, proof.A2.Y), elliptic.Marshal(curve, G.X, G.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// 2. Verifier computes left and right sides for the first equation: G^z_v H^z_s1 == A1 * C1^e
	leftG1 := pointScalarMult(G, proof.Zv)
	leftH1 := pointScalarMult(H, proof.Zs1)
	leftSide1 := pointAdd(leftG1, leftH1)

	C1_e := pointScalarMult(C1, e)
	rightSide1 := pointAdd(proof.A1, C1_e)

	// 3. Verifier computes left and right sides for the second equation: G^z_v H^z_s2 == A2 * C2^e
	leftG2 := pointScalarMult(G, proof.Zv) // Same G^z_v
	leftH2 := pointScalarMult(H, proof.Zs2)
	leftSide2 := pointAdd(leftG2, leftH2)

	C2_e := pointScalarMult(C2, e)
	rightSide2 := pointAdd(proof.A2, C2_e)

	// 4. Verifier checks both equations
	check1 := leftSide1.X.Cmp(rightSide1.X) == 0 && leftSide1.Y.Cmp(rightSide1.Y) == 0
	check2 := leftSide2.X.Cmp(rightSide2.X) == 0 && leftSide2.Y.Cmp(rightSide2.Y) == 0

	return check1 && check2
}


// ProveEqualityOfBlindingFactors proves that the blinding factor used in C1 and C2 is the same.
// C1 = G^v1 * H^r, C2 = G^v2 * H^r. Proves knowledge of v1, r, v2 s.t. this holds.
// This is structurally similar to ProveEqualityOfCommittedValues, swapping roles of G and H.
// Prover picks random s, v1, v2. Computes A1 = G^v1 H^s, A2 = G^v2 H^s.
// Challenge e from C1, C2, A1, A2...
// Response z_s = s + e*r, z_v1 = v1 + e*v1, z_v2 = v2 + e*v2. Wait, this isn't quite right.
// Let's use the equation C1 / G^v1 = H^r and C2 / G^v2 = H^r. Proving equality of H^r.
// Target1 = C1 / G^v1, Target2 = C2 / G^v2. Proving Target1 = Target2 and knowledge of r.
// This requires knowing v1 and v2. A better approach:
// C1/C2 = G^(v1-v2). Prove knowledge of v1-v2 for C1/C2 base G.
// And separately, prove knowledge of r for C1/G^v1 base H OR C2/G^v2 base H.
// This seems more complex than necessary. Let's re-evaluate the statement:
// "I know v1, r, v2 such that C1=G^v1 H^r and C2=G^v2 H^r".
// Prover knows v1, r, v2.
// Prover picks random v1_rand, s_rand, v2_rand.
// Commits: A1 = G^v1_rand H^s_rand, A2 = G^v2_rand H^s_rand.
// Challenge e.
// Responses: z_v1 = v1_rand + e*v1, z_s = s_rand + e*r, z_v2 = v2_rand + e*v2.
// Verifier checks: G^z_v1 H^z_s == A1 * C1^e AND G^z_v2 H^z_s == A2 * C2^e.
// This proves knowledge of v1, r, v2 and the structure.
type BlindingEqualityProof struct {
	A1  *elliptic.Point // Prover's commitment 1 A1 = G^v1_rand * H^s_rand
	A2  *elliptic.Point // Prover's commitment 2 A2 = G^v2_rand * H^s_rand (same s_rand)
	Zv1 *big.Int        // Response z_v1 = v1_rand + e * v1
	Zv2 *big.Int        // Response z_v2 = v2_rand + e * v2
	Zs  *big.Int        // Response z_s = s_rand + e * r
}

func ProveEqualityOfBlindingFactors(C1, C2 *elliptic.Point, v1, r, v2 *big.Int) (*BlindingEqualityProof, error) {
	if C1 == nil || C1.X == nil || C2 == nil || C2.X == nil || v1 == nil || r == nil || v2 == nil {
		return nil, errors.New("invalid inputs")
	}

	// 1. Prover picks random scalars v1_rand, v2_rand, s_rand
	v1_rand, err := randScalar(rand.Reader)
	if err != nil { return nil, fmt.Errorf("failed to generate random v1_rand: %w", err) }
	v2_rand, err := randScalar(rand.Reader)
	if err != nil { return nil, fmt.Errorf("failed to generate random v2_rand: %w", err) }
	s_rand, err := randScalar(rand.Reader)
	if err != nil { return nil, fmt.Errorf("failed to generate random s_rand: %w", err) }

	// 2. Prover computes commitments A1 = G^v1_rand * H^s_rand, A2 = G^v2_rand * H^s_rand
	A1 := pointAdd(pointScalarMult(G, v1_rand), pointScalarMult(H, s_rand))
	A2 := pointAdd(pointScalarMult(G, v2_rand), pointScalarMult(H, s_rand)) // Uses the same s_rand

	// 3. Prover/Verifier generate challenge e
	e := hashToScalar("zkp-blinding-equality-proof", elliptic.Marshal(curve, C1.X, C1.Y), elliptic.Marshal(curve, C2.X, C2.Y), elliptic.Marshal(curve, A1.X, A1.Y), elliptic.Marshal(curve, A2.X, A2.Y), elliptic.Marshal(curve, G.X, G.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// 4. Prover computes responses
	z_v1 := scalarAdd(v1_rand, scalarMul(e, v1))
	z_v2 := scalarAdd(v2_rand, scalarMul(e, v2))
	z_s := scalarAdd(s_rand, scalarMul(e, r))

	// 5. Proof is (A1, A2, z_v1, z_v2, z_s)
	return &BlindingEqualityProof{A1: A1, A2: A2, Zv1: z_v1, Zv2: z_v2, Zs: z_s}, nil
}

// VerifyEqualityOfBlindingFactors verifies the proof generated by ProveEqualityOfBlindingFactors.
// Checks G^z_v1 H^z_s == A1 * C1^e AND G^z_v2 H^z_s == A2 * C2^e.
func VerifyEqualityOfBlindingFactors(C1, C2 *elliptic.Point, proof *BlindingEqualityProof) bool {
	if C1 == nil || C1.X == nil || C2 == nil || C2.X == nil || proof == nil || proof.A1 == nil || proof.A1.X == nil || proof.A2 == nil || proof.A2.X == nil || proof.Zv1 == nil || proof.Zv2 == nil || proof.Zs == nil {
		return false // Invalid inputs
	}

	// 1. Verifier regenerates challenge e
	e := hashToScalar("zkp-blinding-equality-proof", elliptic.Marshal(curve, C1.X, C1.Y), elliptic.Marshal(curve, C2.X, C2.Y), elliptic.Marshal(curve, proof.A1.X, proof.A1.Y), elliptic.Marshal(curve, proof.A2.X, proof.A2.Y), elliptic.Marshal(curve, G.X, G.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// 2. Verifier checks the first equation: G^z_v1 H^z_s == A1 * C1^e
	leftG1 := pointScalarMult(G, proof.Zv1)
	leftH1 := pointScalarMult(H, proof.Zs) // Same H^z_s
	leftSide1 := pointAdd(leftG1, leftH1)
	C1_e := pointScalarMult(C1, e)
	rightSide1 := pointAdd(proof.A1, C1_e)

	// 3. Verifier checks the second equation: G^z_v2 H^z_s == A2 * C2^e
	leftG2 := pointScalarMult(G, proof.Zv2)
	leftH2 := pointScalarMult(H, proof.Zs) // Same H^z_s
	leftSide2 := pointAdd(leftG2, leftH2)
	C2_e := pointScalarMult(C2, e)
	rightSide2 := pointAdd(proof.A2, C2_e)

	// 4. Verifier checks both equations
	check1 := leftSide1.X.Cmp(rightSide1.X) == 0 && leftSide1.Y.Cmp(rightSide1.Y) == 0
	check2 := leftSide2.X.Cmp(rightSide2.X) == 0 && leftSide2.Y.Cmp(rightSide2.Y) == 0

	return check1 && check2
}


// 7. Relationship Proofs (Sum, Difference, Linear Combination, Adjacency, Sum to Zero)

// ProveSumEqualsPublicConstant proves v1 + v2 = publicSum for secrets v1, v2 in C1, C2.
// C1 = G^v1 H^r1, C2 = G^v2 H^r2.
// Statement: v1 + v2 = K (public constant).
// Implies C1 * C2 = G^(v1+v2) H^(r1+r2) = G^K H^(r1+r2).
// Target = C1 * C2 * G^-K = H^(r1+r2).
// Prove knowledge of r_sum = r1+r2 for Target point using base H. This is a single Sigma proof.
func ProveSumEqualsPublicConstant(C1, C2 *elliptic.Point, v1, r1, v2, r2, publicSum *big.Int) (*PublicConstantSumProof, error) {
	if C1 == nil || C1.X == nil || C2 == nil || C2.X == nil || v1 == nil || r1 == nil || v2 == nil || r2 == nil || publicSum == nil {
		return nil, errors.New("invalid inputs")
	}

	// Compute r_sum = r1 + r2 mod N
	r_sum := scalarAdd(r1, r2)

	// 1. Prover picks random scalar s_sum
	s_sum, err := randScalar(rand.Reader)
	if err != nil {
		return nil, fmt.Errorf("failed to generate random s_sum: %w", err)
	}

	// 2. Prover computes commitment A = H^s_sum
	A := pointScalarMult(H, s_sum)

	// 3. Compute the target point T = C1 * C2 * G^-publicSum
	C1_C2 := pointAdd(C1, C2)
	G_negK := pointScalarMult(G, new(big.Int).Neg(publicSum))
	T := pointAdd(C1_C2, G_negK)

	// 4. Prover/Verifier generate challenge e
	e := hashToScalar("zkp-sum-equals-public-proof", elliptic.Marshal(curve, C1.X, C1.Y), elliptic.Marshal(curve, C2.X, C2.Y), publicSum.Bytes(), elliptic.Marshal(curve, A.X, A.Y), elliptic.Marshal(curve, T.X, T.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// 5. Prover computes response z_r = s_sum + e * r_sum mod N
	z_r := scalarAdd(s_sum, scalarMul(e, r_sum))

	// 6. Proof is (A, z_r)
	return &PublicConstantSumProof{A: A, Zr: z_r}, nil
}

// VerifySumEqualsPublicConstant verifies the proof generated by ProveSumEqualsPublicConstant.
// Checks H^z_r == A * T^e, where T = C1 * C2 * G^-publicSum.
func VerifySumEqualsPublicConstant(C1, C2 *elliptic.Point, publicSum *big.Int, proof *PublicConstantSumProof) bool {
	if C1 == nil || C1.X == nil || C2 == nil || C2.X == nil || publicSum == nil || proof == nil || proof.A == nil || proof.A.X == nil || proof.Zr == nil {
		return false // Invalid inputs
	}

	// 1. Compute the target point T = C1 * C2 * G^-publicSum
	C1_C2 := pointAdd(C1, C2)
	G_negK := pointScalarMult(G, new(big.Int).Neg(publicSum))
	T := pointAdd(C1_C2, G_negK)

	// 2. Verifier regenerates challenge e
	e := hashToScalar("zkp-sum-equals-public-proof", elliptic.Marshal(curve, C1.X, C1.Y), elliptic.Marshal(curve, C2.X, C2.Y), publicSum.Bytes(), elliptic.Marshal(curve, proof.A.X, proof.A.Y), elliptic.Marshal(curve, T.X, T.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// 3. Verifier computes the left side: H^z_r
	leftSide := pointScalarMult(H, proof.Zr)

	// 4. Verifier computes the right side: A * T^e
	T_e := pointScalarMult(T, e)
	rightSide := pointAdd(proof.A, T_e)

	// 5. Verifier checks if leftSide == rightSide
	return leftSide.X.Cmp(rightSide.X) == 0 && leftSide.Y.Cmp(rightSide.Y) == 0
}

// ProveDifferenceEqualsPublicConstant proves v1 - v2 = publicDiff for secrets v1, v2 in C1, C2.
// C1 = G^v1 H^r1, C2 = G^v2 H^r2.
// Statement: v1 - v2 = K (public constant).
// Implies C1 / C2 = G^(v1-v2) H^(r1-r2) = G^K H^(r1-r2).
// Target = C1 / C2 * G^-K = H^(r1-r2).
// Prove knowledge of r_diff = r1-r2 for Target point using base H.
func ProveDifferenceEqualsPublicConstant(C1, C2 *elliptic.Point, v1, r1, v2, r2, publicDiff *big.Int) (*PublicConstantDifferenceProof, error) {
	if C1 == nil || C1.X == nil || C2 == nil || C2.X == nil || v1 == nil || r1 == nil || v2 == nil || r2 == nil || publicDiff == nil {
		return nil, errors.New("invalid inputs")
	}

	// Compute r_diff = r1 - r2 mod N
	r_diff := scalarSub(r1, r2)

	// 1. Prover picks random scalar s_diff
	s_diff, err := randScalar(rand.Reader)
	if err != nil {
		return nil, fmt.Errorf("failed to generate random s_diff: %w", err)
	}

	// 2. Prover computes commitment A = H^s_diff
	A := pointScalarMult(H, s_diff)

	// 3. Compute the target point T = C1 / C2 * G^-publicDiff
	C1_div_C2 := pointSub(C1, C2) // C1 + (-C2)
	G_negK := pointScalarMult(G, new(big.Int).Neg(publicDiff))
	T := pointAdd(C1_div_C2, G_negK)

	// 4. Prover/Verifier generate challenge e
	e := hashToScalar("zkp-diff-equals-public-proof", elliptic.Marshal(curve, C1.X, C1.Y), elliptic.Marshal(curve, C2.X, C2.Y), publicDiff.Bytes(), elliptic.Marshal(curve, A.X, A.Y), elliptic.Marshal(curve, T.X, T.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// 5. Prover computes response z_r = s_diff + e * r_diff mod N
	z_r := scalarAdd(s_diff, scalarMul(e, r_diff))

	// 6. Proof is (A, z_r)
	return &PublicConstantDifferenceProof{A: A, Zr: z_r}, nil
}

// VerifyDifferenceEqualsPublicConstant verifies the proof generated by ProveDifferenceEqualsPublicConstant.
// Checks H^z_r == A * T^e, where T = C1 / C2 * G^-publicDiff.
func VerifyDifferenceEqualsPublicConstant(C1, C2 *elliptic.Point, publicDiff *big.Int, proof *PublicConstantDifferenceProof) bool {
	if C1 == nil || C1.X == nil || C2 == nil || C2.X == nil || publicDiff == nil || proof == nil || proof.A == nil || proof.A.X == nil || proof.Zr == nil {
		return false // Invalid inputs
	}

	// 1. Compute the target point T = C1 / C2 * G^-publicDiff
	C1_div_C2 := pointSub(C1, C2)
	G_negK := pointScalarMult(G, new(big.Int).Neg(publicDiff))
	T := pointAdd(C1_div_C2, G_negK)

	// 2. Verifier regenerates challenge e
	e := hashToScalar("zkp-diff-equals-public-proof", elliptic.Marshal(curve, C1.X, C1.Y), elliptic.Marshal(curve, C2.X, C2.Y), publicDiff.Bytes(), elliptic.Marshal(curve, proof.A.X, proof.A.Y), elliptic.Marshal(curve, T.X, T.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// 3. Verifier computes the left side: H^z_r
	leftSide := pointScalarMult(H, proof.Zr)

	// 4. Verifier computes the right side: A * T^e
	T_e := pointScalarMult(T, e)
	rightSide := pointAdd(proof.A, T_e)

	// 5. Verifier checks if leftSide == rightSide
	return leftSide.X.Cmp(rightSide.X) == 0 && leftSide.Y.Cmp(rightSide.Y) == 0
}

// ProveLinearCombinationEqualsPublicConstant proves sum(coeffs[i] * vs[i]) = publicConstant.
// C_i = G^v_i H^r_i. Statement: sum(a_i * v_i) = K.
// Implies prod(C_i^a_i) = prod((G^v_i H^r_i)^a_i) = prod(G^(a_i*v_i) H^(a_i*r_i)) = G^(sum(a_i*v_i)) H^(sum(a_i*r_i)) = G^K H^(sum(a_i*r_i)).
// Target = prod(C_i^a_i) * G^-K = H^(sum(a_i*r_i)).
// Prove knowledge of r_sum_coeffs = sum(a_i*r_i) for Target point using base H.
func ProveLinearCombinationEqualsPublicConstant(Cs []*elliptic.Point, vs, rs, coeffs []*big.Int, publicConstant *big.Int) (*LinearCombinationProof, error) {
	if len(Cs) == 0 || len(Cs) != len(vs) || len(vs) != len(rs) || len(rs) != len(coeffs) || publicConstant == nil {
		return nil, errors.New("invalid inputs or unequal lengths")
	}

	// Compute r_sum_coeffs = sum(coeffs[i] * rs[i]) mod N
	r_sum_coeffs := big.NewInt(0)
	for i := range coeffs {
		term := scalarMul(coeffs[i], rs[i])
		r_sum_coeffs = scalarAdd(r_sum_coeffs, term)
	}

	// 1. Prover picks random scalar s_sum_coeffs_r
	s_sum_coeffs_r, err := randScalar(rand.Reader)
	if err != nil {
		return nil, fmt.Errorf("failed to generate random scalar: %w", err)
	}

	// 2. Prover computes commitment A = H^s_sum_coeffs_r
	A := pointScalarMult(H, s_sum_coeffs_r)

	// 3. Compute the target point T = prod(C_i^coeffs[i]) * G^-publicConstant
	prod_C_coeffs := elliptic.NewCurvePoint(curve, nil, nil) // Point at infinity (identity for addition)
	for i := range Cs {
		C_i_pow_coeff_i := pointScalarMult(Cs[i], coeffs[i])
		prod_C_coeffs = pointAdd(prod_C_coeffs, C_i_pow_coeff_i)
	}
	G_negK := pointScalarMult(G, new(big.Int).Neg(publicConstant))
	T := pointAdd(prod_C_coeffs, G_negK)

	// 4. Prover/Verifier generate challenge e
	hashInputs := [][]byte{}
	for _, C := range Cs {
		hashInputs = append(hashInputs, elliptic.Marshal(curve, C.X, C.Y))
	}
	for _, coeff := range coeffs {
		hashInputs = append(hashInputs, coeff.Bytes())
	}
	hashInputs = append(hashInputs, publicConstant.Bytes(), elliptic.Marshal(curve, A.X, A.Y), elliptic.Marshal(curve, T.X, T.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())
	e := hashToScalar("zkp-linear-comb-public-proof", hashInputs...)

	// 5. Prover computes response z_r = s_sum_coeffs_r + e * r_sum_coeffs mod N
	z_r := scalarAdd(s_sum_coeffs_r, scalarMul(e, r_sum_coeffs))

	// 6. Proof is (A, z_r)
	return &LinearCombinationProof{A: A, Zr: z_r}, nil
}

// VerifyLinearCombinationEqualsPublicConstant verifies the proof generated by ProveLinearCombinationEqualsPublicConstant.
// Checks H^z_r == A * T^e, where T = prod(C_i^coeffs[i]) * G^-publicConstant.
func VerifyLinearCombinationEqualsPublicConstant(Cs []*elliptic.Point, coeffs []*big.Int, publicConstant *big.Int, proof *LinearCombinationProof) bool {
	if len(Cs) == 0 || len(Cs) != len(coeffs) || publicConstant == nil || proof == nil || proof.A == nil || proof.A.X == nil || proof.Zr == nil {
		return false // Invalid inputs or unequal lengths
	}

	// 1. Compute the target point T = prod(C_i^coeffs[i]) * G^-publicConstant
	prod_C_coeffs := elliptic.NewCurvePoint(curve, nil, nil) // Point at infinity
	for i := range Cs {
		if Cs[i] == nil || Cs[i].X == nil || coeffs[i] == nil { return false } // Check for nil points/coeffs
		C_i_pow_coeff_i := pointScalarMult(Cs[i], coeffs[i])
		prod_C_coeffs = pointAdd(prod_C_coeffs, C_i_pow_coeff_i)
	}
	G_negK := pointScalarMult(G, new(big.Int).Neg(publicConstant))
	T := pointAdd(prod_C_coeffs, G_negK)
	if T.X == nil { return false } // Check if T is point at infinity after computation (shouldn't be if valid inputs)


	// 2. Verifier regenerates challenge e
	hashInputs := [][]byte{}
	for _, C := range Cs {
		hashInputs = append(hashInputs, elliptic.Marshal(curve, C.X, C.Y))
	}
	for _, coeff := range coeffs {
		hashInputs = append(hashInputs, coeff.Bytes())
	}
	hashInputs = append(hashInputs, publicConstant.Bytes(), elliptic.Marshal(curve, proof.A.X, proof.A.Y), elliptic.Marshal(curve, T.X, T.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())
	e := hashToScalar("zkp-linear-comb-public-proof", hashInputs...)

	// 3. Verifier computes the left side: H^z_r
	leftSide := pointScalarMult(H, proof.Zr)

	// 4. Verifier computes the right side: A * T^e
	T_e := pointScalarMult(T, e)
	rightSide := pointAdd(proof.A, T_e)

	// 5. Verifier checks if leftSide == rightSide
	return leftSide.X.Cmp(rightSide.X) == 0 && leftSide.Y.Cmp(rightSide.Y) == 0
}


// ProveSecretsAreAdjacent proves v2 = v1 + 1 for secrets v1, v2 in C1, C2.
// This is a special case of ProveDifferenceEqualsPublicConstant where publicDiff = 1.
func ProveSecretsAreAdjacent(C1, C2 *elliptic.Point, v1, r1, v2, r2 *big.Int) (*AdjacentProof, error) {
	if C1 == nil || C1.X == nil || C2 == nil || C2.X == nil || v1 == nil || r1 == nil || v2 == nil || r2 == nil {
		return nil, errors.New("invalid inputs")
	}
	publicDiff := big.NewInt(1)
	proof, err := ProveDifferenceEqualsPublicConstant(C1, C2, v1, r1, v2, r2, publicDiff)
	if err != nil {
		return nil, err
	}
	// Cast the proof to AdjacentProof
	return &AdjacentProof{A: proof.A, Zr: proof.Zr}, nil
}

// VerifySecretsAreAdjacent verifies the proof generated by ProveSecretsAreAdjacent.
// This is a special case of VerifyDifferenceEqualsPublicConstant where publicDiff = 1.
func VerifySecretsAreAdjacent(C1, C2 *elliptic.Point, proof *AdjacentProof) bool {
	if C1 == nil || C1.X == nil || C2 == nil || C2.X == nil || proof == nil || proof.A == nil || proof.A.X == nil || proof.Zr == nil {
		return false // Invalid inputs
	}
	publicDiff := big.NewInt(1)
	// Use the underlying verification logic
	dummyProof := &PublicConstantDifferenceProof{A: proof.A, Zr: proof.Zr}
	return VerifyDifferenceEqualsPublicConstant(C1, C2, publicDiff, dummyProof)
}

// ProveSecretsSumToZero proves v1 + v2 = 0 for secrets v1, v2 in C1, C2.
// This is a special case of ProveSumEqualsPublicConstant where publicSum = 0.
func ProveSecretsSumToZero(C1, C2 *elliptic.Point, v1, r1, v2, r2 *big.Int) (*SumZeroProof, error) {
	if C1 == nil || C1.X == nil || C2 == nil || C2.X == nil || v1 == nil || r1 == nil || v2 == nil || r2 == nil {
		return nil, errors.New("invalid inputs")
	}
	publicSum := big.NewInt(0)
	proof, err := ProveSumEqualsPublicConstant(C1, C2, v1, r1, v2, r2, publicSum)
	if err != nil {
		return nil, err
	}
	// Cast the proof to SumZeroProof
	return &SumZeroProof{A: proof.A, Zr: proof.Zr}, nil
}

// VerifySecretsSumToZero verifies the proof generated by ProveSecretsSumToZero.
// This is a special case of VerifySumEqualsPublicConstant where publicSum = 0.
func VerifySecretsSumToZero(C1, C2 *elliptic.Point, proof *SumZeroProof) bool {
	if C1 == nil || C1.X == nil || C2 == nil || C2.X == nil || proof == nil || proof.A == nil || proof.A.X == nil || proof.Zr == nil {
		return false // Invalid inputs
	}
	publicSum := big.NewInt(0)
	// Use the underlying verification logic
	dummyProof := &PublicConstantSumProof{A: proof.A, Zr: proof.Zr}
	return VerifySumEqualsPublicConstant(C1, C2, publicSum, dummyProof)
}


// 8. Property Proofs (Even, Odd, Multiple of Public, Equals Public Constant)

// ProveValueIsEven proves the secret 'value' in C is an even number.
// C = G^value H^blinding, where value = 2k for some integer k.
// C = G^(2k) H^blinding = (G^2)^k H^blinding.
// Prove knowledge of k, blinding for C using generators G' = G^2 and H' = H.
func ProveValueIsEven(C *elliptic.Point, value, blinding *big.Int) (*EvenOddProof, error) {
	if C == nil || C.X == nil || C.Y == nil || value == nil || blinding == nil {
		return nil, errors.New("invalid inputs")
	}
	if new(big.Int).Mod(value, big.NewInt(2)).Cmp(big.NewInt(0)) != 0 {
		return nil, errors.New("secret value is not even")
	}
	k := new(big.Int).Div(value, big.NewInt(2)) // k = value / 2

	// New generator G' = G^2
	G_prime := pointScalarMult(G, big.NewInt(2))

	// Prover picks random scalars v, s
	v, err := randScalar(rand.Reader)
	if err != nil { return nil, fmt.Errorf("failed to generate random v: %w", err) }
	s, err := randScalar(rand.Reader)
	if err != nil { return nil, fmt.Errorf("failed to generate random s: %w", err) }

	// Prover computes commitment A = (G^2)^v * H^s
	termG_prime := pointScalarMult(G_prime, v)
	termH := pointScalarMult(H, s)
	A := pointAdd(termG_prime, termH)

	// Prover/Verifier generate challenge e
	e := hashToScalar("zkp-even-proof", elliptic.Marshal(curve, C.X, C.Y), elliptic.Marshal(curve, A.X, A.Y), elliptic.Marshal(curve, G_prime.X, G_prime.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// Prover computes responses z_k = v + e*k mod N, z_r = s + e*blinding mod N
	z_k := scalarAdd(v, scalarMul(e, k))
	z_r := scalarAdd(s, scalarMul(e, blinding))

	return &EvenOddProof{A: A, Zk: z_k, Zr: z_r}, nil
}

// VerifyValueIsEven verifies the proof generated by ProveValueIsEven.
// Checks (G^2)^z_k * H^z_r == A * C^e.
func VerifyValueIsEven(C *elliptic.Point, proof *EvenOddProof) bool {
	if C == nil || C.X == nil || C.Y == nil || proof == nil || proof.A == nil || proof.A.X == nil || proof.A.Y == nil || proof.Zk == nil || proof.Zr == nil {
		return false // Invalid inputs
	}
	// New generator G' = G^2
	G_prime := pointScalarMult(G, big.NewInt(2))
	if G_prime.X == nil { return false } // Should not happen

	// Verifier regenerates challenge e
	e := hashToScalar("zkp-even-proof", elliptic.Marshal(curve, C.X, C.Y), elliptic.Marshal(curve, proof.A.X, proof.A.Y), elliptic.Marshal(curve, G_prime.X, G_prime.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// Verifier computes left side: (G^2)^z_k * H^z_r
	leftG_prime := pointScalarMult(G_prime, proof.Zk)
	leftH := pointScalarMult(H, proof.Zr)
	leftSide := pointAdd(leftG_prime, leftH)

	// Verifier computes right side: A * C^e
	C_e := pointScalarMult(C, e)
	rightSide := pointAdd(proof.A, C_e)

	return leftSide.X.Cmp(rightSide.X) == 0 && leftSide.Y.Cmp(rightSide.Y) == 0
}

// ProveValueIsOdd proves the secret 'value' in C is an odd number.
// C = G^value H^blinding, where value = 2k+1 for some integer k.
// C = G^(2k+1) H^blinding = G * G^(2k) * H^blinding = G * (G^2)^k * H^blinding.
// C * G^-1 = (G^2)^k * H^blinding.
// Prove knowledge of k, blinding for C * G^-1 using generators G' = G^2 and H' = H.
func ProveValueIsOdd(C *elliptic.Point, value, blinding *big.Int) (*EvenOddProof, error) {
	if C == nil || C.X == nil || C.Y == nil || value == nil || blinding == nil {
		return nil, errors.New("invalid inputs")
	}
	if new(big.Int).Mod(value, big.NewInt(2)).Cmp(big.NewInt(1)) != 0 {
		return nil, errors.New("secret value is not odd")
	}
	// value = 2k + 1 => k = (value - 1) / 2
	k_val := new(big.Int).Sub(value, big.NewInt(1))
	k := new(big.Int).Div(k_val, big.NewInt(2))

	// New generator G' = G^2
	G_prime := pointScalarMult(G, big.NewInt(2))

	// Prover picks random scalars v, s
	v, err := randScalar(rand.Reader)
	if err != nil { return nil, fmt.Errorf("failed to generate random v: %w", err) }
	s, err := randScalar(rand.Reader)
	if err != nil { return nil, fmt.Errorf("failed to generate random s: %w", err) }

	// Prover computes commitment A = (G^2)^v * H^s
	termG_prime := pointScalarMult(G_prime, v)
	termH := pointScalarMult(H, s)
	A := pointAdd(termG_prime, termH)

	// Compute the target point T = C * G^-1
	G_neg1 := pointScalarMult(G, big.NewInt(-1))
	T := pointAdd(C, G_neg1)

	// Prover/Verifier generate challenge e
	e := hashToScalar("zkp-odd-proof", elliptic.Marshal(curve, C.X, C.Y), elliptic.Marshal(curve, T.X, T.Y), elliptic.Marshal(curve, A.X, A.Y), elliptic.Marshal(curve, G_prime.X, G_prime.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// Prover computes responses z_k = v + e*k mod N, z_r = s + e*blinding mod N
	z_k := scalarAdd(v, scalarMul(e, k))
	z_r := scalarAdd(s, scalarMul(e, blinding))

	return &EvenOddProof{A: A, Zk: z_k, Zr: z_r}, nil
}

// VerifyValueIsOdd verifies the proof generated by ProveValueIsOdd.
// Checks (G^2)^z_k * H^z_r == A * T^e, where T = C * G^-1.
func VerifyValueIsOdd(C *elliptic.Point, proof *EvenOddProof) bool {
	if C == nil || C.X == nil || C.Y == nil || proof == nil || proof.A == nil || proof.A.X == nil || proof.A.Y == nil || proof.Zk == nil || proof.Zr == nil {
		return false // Invalid inputs
	}

	// New generator G' = G^2
	G_prime := pointScalarMult(G, big.NewInt(2))
	if G_prime.X == nil { return false } // Should not happen

	// Compute the target point T = C * G^-1
	G_neg1 := pointScalarMult(G, big.NewInt(-1))
	T := pointAdd(C, G_neg1)
	if T.X == nil { return false } // Should not happen

	// Verifier regenerates challenge e
	e := hashToScalar("zkp-odd-proof", elliptic.Marshal(curve, C.X, C.Y), elliptic.Marshal(curve, T.X, T.Y), elliptic.Marshal(curve, proof.A.X, proof.A.Y), elliptic.Marshal(curve, G_prime.X, G_prime.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// Verifier computes left side: (G^2)^z_k * H^z_r
	leftG_prime := pointScalarMult(G_prime, proof.Zk)
	leftH := pointScalarMult(H, proof.Zr)
	leftSide := pointAdd(leftG_prime, leftH)

	// Verifier computes right side: A * T^e
	T_e := pointScalarMult(T, e)
	rightSide := pointAdd(proof.A, T_e)

	return leftSide.X.Cmp(rightSide.X) == 0 && leftSide.Y.Cmp(rightSide.Y) == 0
}

// ProveValueIsMultipleOfPublic proves the secret 'value' in C is a multiple of 'publicFactor'.
// C = G^value H^blinding, where value = k * publicFactor for some integer k.
// C = G^(k * publicFactor) H^blinding = (G^publicFactor)^k H^blinding.
// Prove knowledge of k, blinding for C using generators G'' = G^publicFactor and H' = H.
func ProveValueIsMultipleOfPublic(C *elliptic.Point, value, blinding, publicFactor *big.Int) (*MultipleProof, error) {
	if C == nil || C.X == nil || C.Y == nil || value == nil || blinding == nil || publicFactor == nil || publicFactor.Sign() == 0 {
		return nil, errors.New("invalid inputs (publicFactor cannot be zero)")
	}
	if new(big.Int).Mod(value, publicFactor).Cmp(big.NewInt(0)) != 0 {
		return nil, errors.New("secret value is not a multiple of public factor")
	}
	k := new(big.Int).Div(value, publicFactor) // k = value / publicFactor

	// New generator G'' = G^publicFactor
	G_double_prime := pointScalarMult(G, publicFactor)
	if G_double_prime.X == nil { return nil, errors.New("failed to compute G^publicFactor") }

	// Prover picks random scalars v, s
	v, err := randScalar(rand.Reader)
	if err != nil { return nil, fmt.Errorf("failed to generate random v: %w", err) }
	s, err := randScalar(rand.Reader)
	if err != nil { return nil, fmt.Errorf("failed to generate random s: %w", err) }

	// Prover computes commitment A = (G^publicFactor)^v * H^s
	termG_double_prime := pointScalarMult(G_double_prime, v)
	termH := pointScalarMult(H, s)
	A := pointAdd(termG_double_prime, termH)

	// Prover/Verifier generate challenge e
	e := hashToScalar("zkp-multiple-proof", elliptic.Marshal(curve, C.X, C.Y), publicFactor.Bytes(), elliptic.Marshal(curve, A.X, A.Y), elliptic.Marshal(curve, G_double_prime.X, G_double_prime.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// Prover computes responses z_k = v + e*k mod N, z_r = s + e*blinding mod N
	z_k := scalarAdd(v, scalarMul(e, k))
	z_r := scalarAdd(s, scalarMul(e, blinding))

	return &MultipleProof{A: A, Zk: z_k, Zr: z_r}, nil
}

// VerifyValueIsMultipleOfPublic verifies the proof generated by ProveValueIsMultipleOfPublic.
// Checks (G^publicFactor)^z_k * H^z_r == A * C^e.
func VerifyValueIsMultipleOfPublic(C *elliptic.Point, publicFactor *big.Int, proof *MultipleProof) bool {
	if C == nil || C.X == nil || C.Y == nil || publicFactor == nil || publicFactor.Sign() == 0 || proof == nil || proof.A == nil || proof.A.X == nil || proof.A.Y == nil || proof.Zk == nil || proof.Zr == nil {
		return false // Invalid inputs
	}

	// New generator G'' = G^publicFactor
	G_double_prime := pointScalarMult(G, publicFactor)
	if G_double_prime.X == nil { return false }

	// Verifier regenerates challenge e
	e := hashToScalar("zkp-multiple-proof", elliptic.Marshal(curve, C.X, C.Y), publicFactor.Bytes(), elliptic.Marshal(curve, proof.A.X, proof.A.Y), elliptic.Marshal(curve, G_double_prime.X, G_double_prime.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// Verifier computes left side: (G^publicFactor)^z_k * H^z_r
	leftG_double_prime := pointScalarMult(G_double_prime, proof.Zk)
	leftH := pointScalarMult(H, proof.Zr)
	leftSide := pointAdd(leftG_double_prime, leftH)

	// Verifier computes right side: A * C^e
	C_e := pointScalarMult(C, e)
	rightSide := pointAdd(proof.A, C_e)

	return leftSide.X.Cmp(rightSide.X) == 0 && leftSide.Y.Cmp(rightSide.Y) == 0
}

// ProveValueEqualsPublicConstant proves the secret 'value' in C is equal to 'publicValue'.
// C = G^value H^blinding. Statement: value = K (public constant).
// Implies C = G^K H^blinding. C * G^-K = H^blinding.
// Prove knowledge of 'blinding' for C * G^-K using base H. This is a single Sigma proof.
func ProveValueEqualsPublicConstant(C *elliptic.Point, value, blinding, publicValue *big.Int) (*PublicConstantEqualityProof, error) {
	if C == nil || C.X == nil || C.Y == nil || value == nil || blinding == nil || publicValue == nil {
		return nil, errors.New("invalid inputs")
	}
	if value.Cmp(publicValue) != 0 {
		return nil, errors.New("secret value does not equal public value")
	}

	// Compute the target point T = C * G^-publicValue
	G_negK := pointScalarMult(G, new(big.Int).Neg(publicValue))
	T := pointAdd(C, G_negK)
	if T.X == nil { return nil, errors.New("failed to compute target point T") }

	// 1. Prover picks random scalar s
	s, err := randScalar(rand.Reader)
	if err != nil {
		return nil, fmt.Errorf("failed to generate random s: %w", err)
	}

	// 2. Prover computes commitment A = H^s
	A := pointScalarMult(H, s)

	// 3. Prover/Verifier generate challenge e
	e := hashToScalar("zkp-value-equals-public-proof", elliptic.Marshal(curve, C.X, C.Y), publicValue.Bytes(), elliptic.Marshal(curve, A.X, A.Y), elliptic.Marshal(curve, T.X, T.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// 4. Prover computes response z_r = s + e * blinding mod N
	z_r := scalarAdd(s, scalarMul(e, blinding))

	// 5. Proof is (A, z_r)
	return &PublicConstantEqualityProof{A: A, Zr: z_r}, nil
}

// VerifyValueEqualsPublicConstant verifies the proof generated by ProveValueEqualsPublicConstant.
// Checks H^z_r == A * T^e, where T = C * G^-publicValue.
func VerifyValueEqualsPublicConstant(C *elliptic.Point, publicValue *big.Int, proof *PublicConstantEqualityProof) bool {
	if C == nil || C.X == nil || C.Y == nil || publicValue == nil || proof == nil || proof.A == nil || proof.A.X == nil || proof.A.Y == nil || proof.Zr == nil {
		return false // Invalid inputs
	}

	// 1. Compute the target point T = C * G^-publicValue
	G_negK := pointScalarMult(G, new(big.Int).Neg(publicValue))
	T := pointAdd(C, G_negK)
	if T.X == nil { return false } // Should not happen

	// 2. Verifier regenerates challenge e
	e := hashToScalar("zkp-value-equals-public-proof", elliptic.Marshal(curve, C.X, C.Y), publicValue.Bytes(), elliptic.Marshal(curve, proof.A.X, proof.A.Y), elliptic.Marshal(curve, T.X, T.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// 3. Verifier computes the left side: H^z_r
	leftSide := pointScalarMult(H, proof.Zr)

	// 4. Verifier computes the right side: A * T^e
	T_e := pointScalarMult(T, e)
	rightSide := pointAdd(proof.A, T_e)

	// 5. Verifier checks if leftSide == rightSide
	return leftSide.X.Cmp(rightSide.X) == 0 && leftSide.Y.Cmp(rightSide.Y) == 0
}


// 9. Composed Proofs (Committed value is Private Key, Value is One of Public List)

// ProveKnowledgeOfPrivateKey proves committed value is SK for PK and committed in C.
// C = G^value H^blinding AND G^value = publicKey.
// Prover knows value, blinding, and confirms G^value == publicKey.
// Proof uses a combined Sigma protocol: prove knowledge of 'value' for both C and publicKey.
// Prover picks random v, s. Computes A_c = G^v H^s (commitment for C part), A_pk = G^v (commitment for PK part, uses same v).
// Challenge e from C, publicKey, A_c, A_pk...
// Responses z_v = v + e*value, z_s = s + e*blinding.
// Verifier checks G^z_v H^z_s == A_c * C^e AND G^z_v == A_pk * publicKey^e.
func ProveKnowledgeOfPrivateKey(C *elliptic.Point, value, blinding *big.Int, publicKey *elliptic.Point) (*PrivateKeyProof, error) {
	if C == nil || C.X == nil || C.Y == nil || value == nil || blinding == nil || publicKey == nil || publicKey.X == nil || publicKey.Y == nil {
		return nil, errors.New("invalid inputs")
	}

	// Optional sanity check: Does G^value == publicKey? (Prover should know this)
	G_value := pointScalarMult(G, value)
	if G_value.X.Cmp(publicKey.X) != 0 || G_value.Y.Cmp(publicKey.Y) != 0 {
		// This is a check for the prover's inputs, not a ZK check.
		// A dishonest prover could provide incorrect inputs.
		// In a real system, the prover is assumed to be honest-but-curious.
		// If inputs are inconsistent, the proof will fail verification anyway.
		// fmt.Println("Warning: Prover's secret value does not match provided public key.")
		// return nil, errors.New("prover input inconsistency") // Or allow the proof to proceed and fail verification
	}


	// 1. Prover picks random scalars v, s
	v, err := randScalar(rand.Reader)
	if err != nil { return nil, fmt.Errorf("failed to generate random v: %w", err) }
	s, err := randScalar(rand.Reader)
	if err != nil { return nil, fmt.Errorf("failed to generate random s: %w", err) }

	// 2. Prover computes commitments A_c = G^v * H^s, A_pk = G^v
	A_c := pointAdd(pointScalarMult(G, v), pointScalarMult(H, s))
	A_pk := pointScalarMult(G, v) // Uses the same random v

	// 3. Prover/Verifier generate challenge e
	e := hashToScalar("zkp-private-key-proof", elliptic.Marshal(curve, C.X, C.Y), elliptic.Marshal(curve, publicKey.X, publicKey.Y), elliptic.Marshal(curve, A_c.X, A_c.Y), elliptic.Marshal(curve, A_pk.X, A_pk.Y), elliptic.Marshal(curve, G.X, G.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// 4. Prover computes responses z_v = v + e*value mod N, z_s = s + e*blinding mod N
	z_v := scalarAdd(v, scalarMul(e, value))
	z_s := scalarAdd(s, scalarMul(e, blinding))

	// 5. Proof is (A_c, A_pk, z_v, z_s)
	return &PrivateKeyProof{CommitmentA: A_c, PublicKeyA: A_pk, Zv: z_v, Zs: z_s}, nil
}

// VerifyKnowledgeOfPrivateKey verifies the proof generated by ProveKnowledgeOfPrivateKey.
// Checks G^z_v H^z_s == A_c * C^e AND G^z_v == A_pk * publicKey^e.
func VerifyKnowledgeOfPrivateKey(C *elliptic.Point, publicKey *elliptic.Point, proof *PrivateKeyProof) bool {
	if C == nil || C.X == nil || C.Y == nil || publicKey == nil || publicKey.X == nil || publicKey.Y == nil || proof == nil || proof.CommitmentA == nil || proof.CommitmentA.X == nil || proof.PublicKeyA == nil || proof.PublicKeyA.X == nil || proof.Zv == nil || proof.Zs == nil {
		return false // Invalid inputs
	}

	// 1. Verifier regenerates challenge e
	e := hashToScalar("zkp-private-key-proof", elliptic.Marshal(curve, C.X, C.Y), elliptic.Marshal(curve, publicKey.X, publicKey.Y), elliptic.Marshal(curve, proof.CommitmentA.X, proof.CommitmentA.Y), elliptic.Marshal(curve, proof.PublicKeyA.X, proof.PublicKeyA.Y), elliptic.Marshal(curve, G.X, G.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// 2. Verifier checks the first equation (C part): G^z_v H^z_s == A_c * C^e
	leftG_c := pointScalarMult(G, proof.Zv)
	leftH_c := pointScalarMult(H, proof.Zs)
	leftSide_c := pointAdd(leftG_c, leftH_c)
	C_e := pointScalarMult(C, e)
	rightSide_c := pointAdd(proof.CommitmentA, C_e)
	checkC := leftSide_c.X.Cmp(rightSide_c.X) == 0 && leftSide_c.Y.Cmp(rightSide_c.Y) == 0

	// 3. Verifier checks the second equation (PK part): G^z_v == A_pk * publicKey^e
	leftSide_pk := pointScalarMult(G, proof.Zv) // Same G^z_v
	pk_e := pointScalarMult(publicKey, e)
	rightSide_pk := pointAdd(proof.PublicKeyA, pk_e)
	checkPK := leftSide_pk.X.Cmp(rightSide_pk.X) == 0 && leftSide_pk.Y.Cmp(rightSide_pk.Y) == 0

	return checkC && checkPK
}


// ProveValueIsOneOfPublicList proves the secret 'value' in C is equal to one of the values in 'publicList'.
// This implements a Chaum-Pedersen OR proof for N=2 values: value == V1 OR value == V2.
// Statement: (value = V1 AND know r) OR (value = V2 AND know r).
// This is equivalent to proving knowledge of r for (C * G^-V1) base H OR knowledge of r for (C * G^-V2) base H.
// Let Target1 = C * G^-V1, Target2 = C * G^-V2. Prove (know r for Target1) OR (know r for Target2).
// Prover knows value, r. Let's assume value = V_actual (either V1 or V2).
// Prover picks random s_rand. Computes A_rand = H^s_rand. This is the commitment for the *true* statement.
// Prover also picks random challenges e_sim for all *false* statements, and random responses z_sim for all *false* statements.
// For the true statement (e.g., value=V1), e1 is derived (e - e2), and z1 is computed using the real secrets and derived challenge.
// For the false statement (e.g., value=V2), e2 is random, and A2 is computed backwards from e2 and z2.
// Challenge e = Hash(C, V1, V2, A1, A2, ...).
// Case 1: Proving value = V1.
//   Pick random s1, e2. Compute A1 = H^s1. Calculate e1 = e - e2 mod N. Calculate z1 = s1 + e1 * r mod N.
//   Pick random z2. Calculate A2 = H^z2 * Target2^-e2 mod N (Target2 = C * G^-V2).
//   Proof is (A1, z1, e1, A2, z2, e2).
// Case 2: Proving value = V2.
//   Pick random s2, e1. Compute A2 = H^s2. Calculate e2 = e - e1 mod N. Calculate z2 = s2 + e2 * r mod N.
//   Pick random z1. Calculate A1 = H^z1 * Target1^-e1 mod N (Target1 = C * G^-V1).
//   Proof is (A1, z1, e1, A2, z2, e2).
// In the proof struct, we store (A1, z1, e1) and (A2, z2, e2).
// The verifier checks e1+e2 == e and H^z1 == A1 * Target1^e1 and H^z2 == A2 * Target2^e2.
// For simplicity, this implementation only supports a list of size 2.
func ProveValueIsOneOfPublicList(C *elliptic.Point, value, blinding *big.Int, publicList []*big.Int) (*OrProof, error) {
	if C == nil || C.X == nil || C.Y == nil || value == nil || blinding == nil || publicList == nil || len(publicList) != 2 {
		return nil, errors.New("invalid inputs (publicList must have exactly 2 values)")
	}
	V1 := publicList[0]
	V2 := publicList[1]

	// Check if the actual value is one of the public values
	isValueV1 := value.Cmp(V1) == 0
	isValueV2 := value.Cmp(V2) == 0

	if !isValueV1 && !isValueV2 {
		return nil, errors.New("secret value is not in the public list")
	}
	if isValueV1 && isValueV2 {
		// Should not happen unless V1 == V2, which is allowed but trivial.
		// If V1 == V2, the OR proof for 2 options is just a standard Sigma proof for value == V1.
		// We can handle this case specifically or let the OR logic work.
		// Let's assume V1 != V2 for a meaningful OR proof example.
		if V1.Cmp(V2) == 0 {
			return nil, errors.New("public list contains duplicate values")
		}
	}

	// Compute target points T1 = C * G^-V1 and T2 = C * G^-V2
	G_negV1 := pointScalarMult(G, new(big.Int).Neg(V1))
	T1 := pointAdd(C, G_negV1)
	G_negV2 := pointScalarMult(G, new(big.Int).Neg(V2))
	T2 := pointAdd(C, G_negV2)

	// Overall challenge generation starts here to bind A1, A2 later
	// Placeholder challenges/responses until the real one is computed
	// A1, z1, e1 for Target1 and A2, z2, e2 for Target2.
	// One sub-proof is real, the other is simulated.

	var A1, A2 *elliptic.Point
	var z1, z2, e1, e2 *big.Int

	// Generate the overall challenge e = Hash(C, V1, V2, A1, A2, ...)
	// We need A1 and A2 *before* computing e. So we pick randoms for the simulated proof
	// and compute the commitment for the real proof using a random scalar.

	if isValueV1 {
		// Proving value = V1 (Sub-proof 1 is real, Sub-proof 2 is simulated)
		s1_rand, err := randScalar(rand.Reader) // Random for the real proof commitment
		if err != nil { return nil, fmt.Errorf("failed random s1: %w", err) }
		A1 = pointScalarMult(H, s1_rand) // Commitment for the real proof (Target1, knowledge of r)

		// Simulate proof for V2 (pick random z2, e2, compute A2 backwards)
		z2_sim, err := randScalar(rand.Reader)
		if err != nil { return nil, fmt.Errorf("failed random z2 sim: %w", err) }
		e2_sim, err := randScalar(rand.Reader)
		if err != nil { return nil, fmt.Errorf("failed random e2 sim: %w", err) }
		// A2 = H^z2 * Target2^-e2
		Target2_ne2 := pointScalarMult(T2, new(big.Int).Neg(e2_sim))
		A2 = pointAdd(pointScalarMult(H, z2_sim), Target2_ne2)

		// Compute overall challenge e
		hashInputs := [][]byte{elliptic.Marshal(curve, C.X, C.Y), V1.Bytes(), V2.Bytes(), elliptic.Marshal(curve, A1.X, A1.Y), elliptic.Marshal(curve, A2.X, A2.Y), elliptic.Marshal(curve, T1.X, T1.Y), elliptic.Marshal(curve, T2.X, T2.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes()}
		e_overall := hashToScalar("zkp-or-proof-v1-v2", hashInputs...)

		// Compute e1 for the real proof: e1 = e_overall - e2_sim mod N
		e1_real := scalarSub(e_overall, e2_sim)

		// Compute z1 for the real proof: z1 = s1_rand + e1_real * blinding mod N
		z1_real := scalarAdd(s1_rand, scalarMul(e1_real, blinding))

		// Proof components: (A1, z1_real, e1_real) and (A2, z2_sim, e2_sim)
		A1 = A1 // Keep the commitment computed earlier
		z1 = z1_real
		e1 = e1_real
		A2 = A2 // Keep the commitment computed earlier
		z2 = z2_sim
		e2 = e2_sim

	} else if isValueV2 {
		// Proving value = V2 (Sub-proof 2 is real, Sub-proof 1 is simulated)
		s2_rand, err := randScalar(rand.Reader) // Random for the real proof commitment
		if err != nil { return nil, fmt.Errorf("failed random s2: %w", err) }
		A2 = pointScalarMult(H, s2_rand) // Commitment for the real proof (Target2, knowledge of r)

		// Simulate proof for V1 (pick random z1, e1, compute A1 backwards)
		z1_sim, err := randScalar(rand.Reader)
		if err != nil { return nil, fmt.Errorf("failed random z1 sim: %w", err) }
		e1_sim, err := randScalar(rand.Reader)
		if err != nil { return nil, fmt.Errorf("failed random e1 sim: %w", err) }
		// A1 = H^z1 * Target1^-e1
		Target1_ne1 := pointScalarMult(T1, new(big.Int).Neg(e1_sim))
		A1 = pointAdd(pointScalarMult(H, z1_sim), Target1_ne1)

		// Compute overall challenge e
		hashInputs := [][]byte{elliptic.Marshal(curve, C.X, C.Y), V1.Bytes(), V2.Bytes(), elliptic.Marshal(curve, A1.X, A1.Y), elliptic.Marshal(curve, A2.X, A2.Y), elliptic.Marshal(curve, T1.X, T1.Y), elliptic.Marshal(curve, T2.X, T2.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes()}
		e_overall := hashToScalar("zkp-or-proof-v1-v2", hashInputs...)

		// Compute e2 for the real proof: e2 = e_overall - e1_sim mod N
		e2_real := scalarSub(e_overall, e1_sim)

		// Compute z2 for the real proof: z2 = s2_rand + e2_real * blinding mod N
		z2_real := scalarAdd(s2_rand, scalarMul(e2_real, blinding))

		// Proof components: (A1, z1_sim, e1_sim) and (A2, z2_real, e2_real)
		A1 = A1 // Keep the commitment computed earlier
		z1 = z1_sim
		e1 = e1_sim
		A2 = A2 // Keep the commitment computed earlier
		z2 = z2_real
		e2 = e2_real
	} else {
		// Should have been caught by the check above, but defensive programming.
		return nil, errors.New("internal error: value not V1 or V2")
	}

	// Return the proof structure
	return &OrProof{A1: A1, Z1: z1, E1: e1, A2: A2, Z2: z2, E2: e2}, nil
}

// VerifyValueIsOneOfPublicList verifies the proof generated by ProveValueIsOneOfPublicList (for N=2).
// Checks e1 + e2 == e_overall AND H^z1 == A1 * Target1^e1 AND H^z2 == A2 * Target2^e2.
// Where Target1 = C * G^-V1, Target2 = C * G^-V2, and e_overall = Hash(C, V1, V2, A1, A2, ...).
func VerifyValueIsOneOfPublicList(C *elliptic.Point, publicList []*big.Int, proof *OrProof) bool {
	if C == nil || C.X == nil || C.Y == nil || publicList == nil || len(publicList) != 2 || proof == nil || proof.A1 == nil || proof.A1.X == nil || proof.A2 == nil || proof.A2.X == nil || proof.Z1 == nil || proof.Z2 == nil || proof.E1 == nil || proof.E2 == nil {
		return false // Invalid inputs
	}
	V1 := publicList[0]
	V2 := publicList[1]

	// Compute target points T1 = C * G^-V1 and T2 = C * G^-V2
	G_negV1 := pointScalarMult(G, new(big.Int).Neg(V1))
	T1 := pointAdd(C, G_negV1)
	G_negV2 := pointScalarMult(G, new(big.Int).Neg(V2))
	T2 := pointAdd(C, G_negV2)

	if T1.X == nil || T2.X == nil { return false } // Should not happen

	// 1. Verifier regenerates overall challenge e_overall
	hashInputs := [][]byte{elliptic.Marshal(curve, C.X, C.Y), V1.Bytes(), V2.Bytes(), elliptic.Marshal(curve, proof.A1.X, proof.A1.Y), elliptic.Marshal(curve, proof.A2.X, proof.A2.Y), elliptic.Marshal(curve, T1.X, T1.Y), elliptic.Marshal(curve, T2.X, T2.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes()}
	e_overall := hashToScalar("zkp-or-proof-v1-v2", hashInputs...)

	// 2. Verifier checks e1 + e2 == e_overall mod N
	e_sum := scalarAdd(proof.E1, proof.E2)
	if e_sum.Cmp(e_overall) != 0 {
		// fmt.Println("Challenge sum mismatch")
		return false
	}

	// 3. Verifier checks H^z1 == A1 * Target1^e1
	leftSide1 := pointScalarMult(H, proof.Z1)
	Target1_e1 := pointScalarMult(T1, proof.E1)
	rightSide1 := pointAdd(proof.A1, Target1_e1)
	check1 := leftSide1.X.Cmp(rightSide1.X) == 0 && leftSide1.Y.Cmp(rightSide1.Y) == 0
	// if !check1 { fmt.Println("Sub-proof 1 check failed") }

	// 4. Verifier checks H^z2 == A2 * Target2^e2
	leftSide2 := pointScalarMult(H, proof.Z2)
	Target2_e2 := pointScalarMult(T2, proof.E2)
	rightSide2 := pointAdd(proof.A2, Target2_e2)
	check2 := leftSide2.X.Cmp(rightSide2.X) == 0 && leftSide2.Y.Cmp(rightSide2.Y) == 0
	// if !check2 { fmt.Println("Sub-proof 2 check failed") }

	return check1 && check2
}

// 10. Simplified Proofs (Knowledge of Value Only, Knowledge of Blinding Only)

// ProveKnowledgeOfSecretForCommitmentOnly proves knowledge of 'value' for C = G^value (no blinding factor).
// This is a standard Schnorr proof on point C = G^value.
func ProveKnowledgeOfSecretForCommitmentOnly(C *elliptic.Point, value *big.Int) (*ValueOnlyProof, error) {
	if C == nil || C.X == nil || C.Y == nil || value == nil {
		return nil, errors.New("invalid inputs")
	}

	// 1. Prover picks random scalar v
	v, err := randScalar(rand.Reader)
	if err != nil { return nil, fmt.Errorf("failed to generate random v: %w", err) }

	// 2. Prover computes commitment A = G^v
	A := pointScalarMult(G, v)

	// 3. Prover/Verifier generate challenge e = Hash(C, A, G, N)
	e := hashToScalar("zkp-value-only-proof", elliptic.Marshal(curve, C.X, C.Y), elliptic.Marshal(curve, A.X, A.Y), elliptic.Marshal(curve, G.X, G.Y), N.Bytes())

	// 4. Prover computes response z_x = v + e*value mod N
	z_x := scalarAdd(v, scalarMul(e, value))

	// 5. Proof is (A, z_x)
	return &ValueOnlyProof{A: A, Zx: z_x}, nil
}

// VerifyKnowledgeOfSecretForCommitmentOnly verifies the proof generated by ProveKnowledgeOfSecretForCommitmentOnly.
// Checks G^z_x == A * C^e.
func VerifyKnowledgeOfSecretForCommitmentOnly(C *elliptic.Point, proof *ValueOnlyProof) bool {
	if C == nil || C.X == nil || C.Y == nil || proof == nil || proof.A == nil || proof.A.X == nil || proof.A.Y == nil || proof.Zx == nil {
		return false // Invalid inputs
	}

	// 1. Verifier regenerates challenge e
	e := hashToScalar("zkp-value-only-proof", elliptic.Marshal(curve, C.X, C.Y), elliptic.Marshal(curve, proof.A.X, proof.A.Y), elliptic.Marshal(curve, G.X, G.Y), N.Bytes())

	// 2. Verifier computes the left side: G^z_x
	leftSide := pointScalarMult(G, proof.Zx)

	// 3. Verifier computes the right side: A * C^e
	C_e := pointScalarMult(C, e)
	rightSide := pointAdd(proof.A, C_e)

	// 4. Verifier checks if leftSide == rightSide
	return leftSide.X.Cmp(rightSide.X) == 0 && leftSide.Y.Cmp(rightSide.Y) == 0
}

// ProveKnowledgeOfBlindingFactorOnly proves knowledge of 'blinding' for C = H^blinding (no value).
// This is a standard Schnorr proof on point C = H^blinding using base H.
func ProveKnowledgeOfBlindingFactorOnly(C *elliptic.Point, blinding *big.Int) (*BlindingOnlyProof, error) {
	if C == nil || C.X == nil || C.Y == nil || blinding == nil {
		return nil, errors.New("invalid inputs")
	}

	// 1. Prover picks random scalar s
	s, err := randScalar(rand.Reader)
	if err != nil { return nil, fmt.Errorf("failed to generate random s: %w", err) }

	// 2. Prover computes commitment A = H^s
	A := pointScalarMult(H, s)

	// 3. Prover/Verifier generate challenge e = Hash(C, A, H, N)
	e := hashToScalar("zkp-blinding-only-proof", elliptic.Marshal(curve, C.X, C.Y), elliptic.Marshal(curve, A.X, A.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// 4. Prover computes response z_r = s + e*blinding mod N
	z_r := scalarAdd(s, scalarMul(e, blinding))

	// 5. Proof is (A, z_r)
	return &BlindingOnlyProof{A: A, Zr: z_r}, nil
}

// VerifyKnowledgeOfBlindingFactorOnly verifies the proof generated by ProveKnowledgeOfBlindingFactorOnly.
// Checks H^z_r == A * C^e.
func VerifyKnowledgeOfBlindingFactorOnly(C *elliptic.Point, proof *BlindingOnlyProof) bool {
	if C == nil || C.X == nil || C.Y == nil || proof == nil || proof.A == nil || proof.A.X == nil || proof.A.Y == nil || proof.Zr == nil {
		return false // Invalid inputs
	}

	// 1. Verifier regenerates challenge e
	e := hashToScalar("zkp-blinding-only-proof", elliptic.Marshal(curve, C.X, C.Y), elliptic.Marshal(curve, proof.A.X, proof.A.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())

	// 2. Verifier computes the left side: H^z_r
	leftSide := pointScalarMult(H, proof.Zr)

	// 3. Verifier computes the right side: A * C^e
	C_e := pointScalarMult(C, e)
	rightSide := pointAdd(proof.A, C_e)

	// 4. Verifier checks if leftSide == rightSide
	return leftSide.X.Cmp(rightSide.X) == 0 && leftSide.Y.Cmp(rightSide.Y) == 0
}


// 11. Vector/Aggregate Proofs (Sum of Vector Elements)

// ProveKnowledgeOfSecretsForVectorSum proves sum(vs[i]) = publicSum for secrets vs[i] in Cs[i].
// Cs[i] = G^vs[i] H^rs[i]. Statement: sum(vs[i]) = K (public constant).
// Implies prod(Cs[i]) = G^(sum(vs[i])) H^(sum(rs[i])) = G^K H^(sum(rs[i])).
// Target = prod(Cs[i]) * G^-K = H^(sum(rs[i])).
// Prove knowledge of r_sum = sum(rs[i]) for Target point using base H.
// This is a special case of ProveLinearCombinationEqualsPublicConstant with all coeffs = 1.
func ProveKnowledgeOfSecretsForVectorSum(Cs []*elliptic.Point, vs, rs []*big.Int, publicSum *big.Int) (*VectorSumProof, error) {
	if len(Cs) == 0 || len(Cs) != len(vs) || len(vs) != len(rs) || publicSum == nil {
		return nil, errors.New("invalid inputs or unequal lengths")
	}

	// Compute r_sum = sum(rs[i]) mod N
	r_sum := big.NewInt(0)
	for _, r := range rs {
		r_sum = scalarAdd(r_sum, r)
	}

	// 1. Prover picks random scalar s_sum_r
	s_sum_r, err := randScalar(rand.Reader)
	if err != nil { return nil, fmt.Errorf("failed to generate random scalar: %w", err) }

	// 2. Prover computes commitment A = H^s_sum_r
	A := pointScalarMult(H, s_sum_r)

	// 3. Compute the target point T = prod(Cs[i]) * G^-publicSum
	prod_Cs := elliptic.NewCurvePoint(curve, nil, nil) // Point at infinity
	for _, C := range Cs {
		if C == nil || C.X == nil { return nil, errors.New("nil commitment in vector") }
		prod_Cs = pointAdd(prod_Cs, C)
	}
	G_negK := pointScalarMult(G, new(big.Int).Neg(publicSum))
	T := pointAdd(prod_Cs, G_negK)
	if T.X == nil { return nil, errors.New("failed to compute target point T for vector sum") }

	// 4. Prover/Verifier generate challenge e
	hashInputs := [][]byte{}
	for _, C := range Cs {
		hashInputs = append(hashInputs, elliptic.Marshal(curve, C.X, C.Y))
	}
	hashInputs = append(hashInputs, publicSum.Bytes(), elliptic.Marshal(curve, A.X, A.Y), elliptic.Marshal(curve, T.X, T.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())
	e := hashToScalar("zkp-vector-sum-proof", hashInputs...)

	// 5. Prover computes response z_r = s_sum_r + e * r_sum mod N
	z_r := scalarAdd(s_sum_r, scalarMul(e, r_sum))

	// 6. Proof is (A, z_r)
	return &VectorSumProof{A: A, Zr: z_r}, nil
}

// VerifyKnowledgeOfSecretsForVectorSum verifies the proof generated by ProveKnowledgeOfSecretsForVectorSum.
// Checks H^z_r == A * T^e, where T = prod(Cs[i]) * G^-publicSum.
func VerifyKnowledgeOfSecretsForVectorSum(Cs []*elliptic.Point, publicSum *big.Int, proof *VectorSumProof) bool {
	if len(Cs) == 0 || publicSum == nil || proof == nil || proof.A == nil || proof.A.X == nil || proof.Zr == nil {
		return false // Invalid inputs
	}

	// 1. Compute the target point T = prod(Cs[i]) * G^-publicSum
	prod_Cs := elliptic.NewCurvePoint(curve, nil, nil) // Point at infinity
	for _, C := range Cs {
		if C == nil || C.X == nil { return false } // Check for nil commitments
		prod_Cs = pointAdd(prod_Cs, C)
	}
	G_negK := pointScalarMult(G, new(big.Int).Neg(publicSum))
	T := pointAdd(prod_Cs, G_negK)
	if T.X == nil { return false } // Should not happen

	// 2. Verifier regenerates challenge e
	hashInputs := [][]byte{}
	for _, C := range Cs {
		hashInputs = append(hashInputs, elliptic.Marshal(curve, C.X, C.Y))
	}
	hashInputs = append(hashInputs, publicSum.Bytes(), elliptic.Marshal(curve, proof.A.X, proof.A.Y), elliptic.Marshal(curve, T.X, T.Y), elliptic.Marshal(curve, H.X, H.Y), N.Bytes())
	e := hashToScalar("zkp-vector-sum-proof", hashInputs...)

	// 3. Verifier computes the left side: H^z_r
	leftSide := pointScalarMult(H, proof.Zr)

	// 4. Verifier computes the right side: A * T^e
	T_e := pointScalarMult(T, e)
	rightSide := pointAdd(proof.A, T_e)

	// 5. Verifier checks if leftSide == rightSide
	return leftSide.X.Cmp(rightSide.X) == 0 && leftSide.Y.Cmp(rightSide.Y) == 0
}
```